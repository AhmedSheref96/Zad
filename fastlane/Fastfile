default_platform(:android)

require 'dotenv'

platform :android do
  desc "Runs all the tests"
  lane :test do
    gradle(task: "test")
  end

  def get_branch_name
    branch_name = ENV['GIT_BRANCH']
  end


  def update_version_in_gradle(file_path, version_name, version_code)
    unless File.exist?(file_path)
      UI.user_error!("Gradle file not found at #{file_path}. Please check the path.")
    end

    content = File.read(file_path)

    content.gsub!(/versionName\s*=\s*"[\d.]+"/, "versionName = \"#{version_name}\"")
    content.gsub!(/versionCode\s*=\s*\d+/, "versionCode = #{version_code}")

    File.write(file_path, content)
    UI.message("content = #{content}")

    # Step 2: Commit the changes to the repository
    sh("git add -u #{file_path}")
    sh('git commit -m "Update versionCode and versionName"')

    branch_name = get_branch_name()

    sh("git push origin #{branch_name}")

    UI.message("Successfully committed and pushed version updates.")
  end

  lane :tag_commit_if_needed do
    # Step 1: Get the latest commit message
    commit_message = sh("git log -1 --pretty=%B").strip

    # Check if the commit message contains "fixed", "solved", or "finished"
    if commit_message =~ /fixed|solved|finished/i
      # Step 2: Define your tag logic, for example, incrementing the last version tag
      last_tag = sh("git describe --tags `git rev-list --tags --max-count=1` || echo 'v1.0.0'").strip

      if last_tag.nil? || last_tag.empty?
        last_tag = "v1.0.0"  # Default if no tags exist
      end

      # Extract version components from the tag, assuming format v1.2.3
      version_parts = last_tag.gsub('v', '').split('.')
      major = version_parts[0].to_i
      minor = version_parts[1].to_i
      patch = version_parts[2].to_i + 1  # Increment the patch version

      # Generate new tag
      new_tag = "v#{patch}.#{minor}.#{major}"

      # Step 3: Update the version in your Gradle file
      gradle_file = "../app/build.gradle.kts" # Adjust this path as needed
      update_version_in_gradle(gradle_file, new_tag, "#{patch}#{minor}#{major}")

      # Step 5: Add a tag to the new commit
      sh("git tag #{new_tag}")
      UI.message("Tagging commit with tag: #{new_tag}")

      # Step 6: Push the commit and the tag to the remote repository
#       gitlab_token = "glpat-z_5uXHyQceQxM-V-ZsH1"
#       gitlab_origin = "https://oauth2:#{gitlab_token}@gitlab.com/AhmedSheref96/zad.git"

      branch_name = branch_name = get_branch_name()

      sh("git checkout #{branch_name}")
      changes =`git status --porcelain`
      if changes.empty?
        UI.message("No changes to commit. Skipping push.")
        return
      end
      sh("git push origin #{branch_name}")
      sh("git push origin #{branch_name} #{new_tag}")

      UI.message("Pushed commit and tag #{new_tag} to remote repository.")
    else
      UI.message("No relevant commit message found. Skipping tag creation.")
    end
  end


  desc "distribute to app distribution"
  lane :distribute do
    gradle(
      task: "assembleRelease"
    )
    release_notes = get_commits_from_last_tag
    release = firebase_app_distribution(
      app: ENV['APP_ID'],
      service_credentials_file: ENV['FIREBASE_CONDITIONALS_JSON'],
      release_notes: release_notes,
      groups: "operations-team,qa-team",
      debug: false
    )
  end

  lane :get_commits_from_last_tag do
    # Step 1: Get the last tag
    last_tag = sh("git rev-list --tags --max-count=1 | xargs -I {} git describe --tags {} || echo ''").strip

    if last_tag.nil? || last_tag.empty?
      UI.message("No tags found in the repository! Fetching all commits in the branch starting with 'BR-'.")

      # Step 2 (Fallback): Get all commits in the branch that start with 'BR-'
      commit_messages = sh("git log --pretty=format:'%s' --grep='^BR-' || echo ''").strip
    else
      UI.message("Last tag found: #{last_tag}")

      # Step 3: Get commits from the last tag to HEAD that start with 'BR-'
      commit_messages = sh("git log #{last_tag}..HEAD --pretty=format:'%s' --grep='^BR-' || echo ''").strip
    end

    if commit_messages.empty?
      UI.message("No commits starting with 'BR-' found.")
    else
      UI.message("Commits found starting with 'BR-':")
      UI.message(commit_messages)
    end

    # Implicitly return commit_messages
    commit_messages
  end


end
