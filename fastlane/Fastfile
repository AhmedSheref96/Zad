default_platform(:android)

require 'dotenv'

platform :android do
  desc "Runs all the tests"
  lane :test do
    gradle(task: "test")
  end

  desc "Build new development apk"
  lane :development do
#     gradle(task: "clean assembleRelease")
    UI.message("App ID: #{ENV['APP_ID']}")
  end

  lane :update_version_for_new_feature do
    # Step 1: Get the last created tag
    last_tag = sh("git describe --tags $(git rev-list --tags --max-count=1 || echo)").strip rescue nil

    if last_tag.nil? || last_tag.empty?
      UI.message("No tags found, initializing with default version 0.0.1")
      last_tag = "0.0.0"
    end

    # Parse the tag (assumes format "x.y.z")
    major, minor, patch = last_tag.split(".").map(&:to_i)

    # Increment the patch version
    new_patch = patch + 1
    new_tag = "#{major}.#{minor}.#{new_patch}"

    # Set the version name and version code
    version_name = new_tag
    version_code = "#{major}#{minor}#{new_patch}".to_i

    # Update version in build.gradle
    gradle_file = "./app/build.gradle" # Adjust path if needed
    update_version_in_gradle(gradle_file, version_name, version_code)

    # Tag the repository with the new tag
    sh("git tag #{new_tag}")
    sh("git push --tags")

    UI.success("Version updated successfully! New tag: #{new_tag}")
  end


  def update_version_in_gradle(file_path, version_name, version_code)
    content = File.read(file_path)

    # Update versionName and versionCode in the gradle file
    content.gsub!(/versionName\s+"[\d.]+"/, "versionName \"#{version_name}\"")
    content.gsub!(/versionCode\s+\d+/, "versionCode #{version_code}")

    File.write(file_path, content)
  end

  lane :update_version_from_branch_tag do
    # Step 1: Get the last tag in the current branch
    last_tag = sh("git describe --tags $(git rev-list --tags --max-count=1 --no-merges --first-parent)").strip

    if last_tag.empty?
      UI.user_error!("No tags found in the current branch!")
    end

    # Step 2: Parse the tag (assumes format "x.y.z")
    major, minor, patch = last_tag.split(".").map(&:to_i)

    # Increment the patch version
    new_patch = patch + 1
    new_tag = "#{major}.#{minor}.#{new_patch}"

    # Step 3: Set the version name and version code
    version_name = new_tag
    version_code = "#{major}#{minor}#{new_patch}".to_i

    # Update the version name and version code in build.gradle or other config file
    gradle_file = "./app/build.gradle" # Adjust this path as needed
    update_version_in_gradle(gradle_file, version_name, version_code)

    # Step 4: Tag the repository with the new tag (optional)
    sh("git tag #{new_tag}")
    sh("git push --tags")

    UI.success("Version updated successfully! New tag: #{new_tag}")
  end

  def update_version_in_gradle(file_path, version_name, version_code)
    content = File.read(file_path)

    # Update versionName and versionCode in the gradle file
    content.gsub!(/versionName\s+"[\d.]+"/, "versionName \"#{version_name}\"")
    content.gsub!(/versionCode\s+\d+/, "versionCode #{version_code}")

    File.write(file_path, content)
  end


  desc "distribute to app distribution"
  lane :distribute do
    gradle(
      task: "assembleRelease"
    )
    release_notes = get_commits_from_last_tag
    release = firebase_app_distribution(
      app: ENV['APP_ID'],
      service_credentials_file: ENV['FIREBASE_CONDITIONALS_JSON'],
      release_notes: release_notes,
      debug: false
    )
  end

  lane :get_commits_from_last_tag do
    # Step 1: Get the last tag
    last_tag = sh("git describe --tags `git rev-list --tags --max-count=1`").strip

    if last_tag.nil? || last_tag.empty?
      UI.user_error!("No tags found in the repository!")
    end

    UI.message("Last tag found: #{last_tag}")

    # Step 2: Get commits from the last tag to HEAD that start with 'BR-'
    commit_messages = sh("git log #{last_tag}..HEAD --pretty=format:'%s' --grep='^BR-'").strip

    if commit_messages.empty?
      UI.message("No commits starting with 'BR-' found since last tag.")
    else
      UI.message("Commits found starting with 'BR-':")
      UI.message(commit_messages)
    end

    return commit_messages
  end


end
